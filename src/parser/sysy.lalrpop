use crate::parser::ast::*;
use std::rc::Rc;
use std::str::FromStr;

grammar;

pub Program : Program = {
    <cu : CompUnit> => Program {compunit : cu} 
}

CompUnit : CompUnit = {
    <dl : Decl> => { let mut cu = CompUnit{ decls : Vec::new() , funcs : Vec::new() }; cu.decls.push(dl); cu },
    <fd : FuncDef> => { let mut cu = CompUnit{ decls : Vec::new() , funcs : Vec::new() }; cu.funcs.push(fd); cu },
    <mut cu : CompUnit> <dl : Decl> => { cu.decls.push(dl); cu },
    <mut cu : CompUnit> <fd : FuncDef> => { cu.funcs.push(fd); cu }
}

Decl : VarDecl = {
    <cdl : ConstDecl> => cdl,
    <vdl : VarDecl> => vdl,
}

Type : BType = {
    Int => BType::Int,
    Float => BType::Float,
    Void => BType::Void,
}

ConstDecl : VarDecl = {
    Const <ty : Type> <cd : ConstDef> <cds : ("," ConstDef)*> ";" => {
        let mut cdl = VarDecl {ty : ty, vardefs : Vec::new()};
        cdl.vardefs.push(cd);
        cdl.vardefs.append(&mut cds.into_iter().map(|(_, def)| def).collect());
        cdl
    }
}

ConstDef : VarDef = {
    <id : ident> <subscripts : ("[" ConstExp "]")*> "=" <civ : ConstInitVal> => {
        let sub : Vec<_> = subscripts.into_iter().map(|(_, e, _)| e).collect();

        match sub.len(){
            0 => VarDef {ident : id, subscripts : None, init : Some(civ) },
            _ => VarDef {ident : id, subscripts : Some(sub), init : Some(civ) },
        }
    }
}

ConstInitVal : InitVal = {
    <ce : ConstExp> => InitVal::Simple(ce),
    "{}" => InitVal::EmptyArray,
    "{" <civ : ConstInitVal> <civs : ("," ConstInitVal)*> "}" => {
        let mut civ_vec = Vec::new();
        civ_vec.push(civ);
        civ_vec.append(& mut civs.into_iter().map(|(_, ci)| ci).collect());
        InitVal::Array(civ_vec)
    },
}

VarDecl : VarDecl = {
    <ty : Type> <vd : VarDef> <vds : ("," VarDef)*> ";" => {
        let mut vdl = VarDecl {ty : ty, vardefs : Vec::new() };
        vdl.vardefs.push(vd);
        vdl.vardefs.append(& mut vds.into_iter().map(|(_, vd)| vd).collect());
        vdl
    }
}

VarDef : VarDef = {
    <id : ident> <subscripts : ("[" ConstExp "]")*> => {
        let sub : Vec<_> = subscripts.into_iter().map(|(_, e, _)| e).collect();

        match sub.len(){
        0 => VarDef {ident : id, subscripts : None, init : None },
        _ => VarDef {ident : id, subscripts : Some(sub), init : None },
    }
    },
    <id : ident> <subscripts : ("[" ConstExp "]")*> "=" <iv : InitVal> => {
        let sub : Vec<_> = subscripts.into_iter().map(|(_, e, _)| e).collect();

        match sub.len(){    
            0 => VarDef {ident : id, subscripts : None, init : Some(iv) },
            _ => VarDef {ident : id, subscripts : Some(sub), init : Some(iv) },
        }
    },
}

InitVal : InitVal = {
    <e : Exp> => InitVal::Simple(e),
    "{}" => InitVal::EmptyArray,
    "{" <iv : InitVal> <ivs : ("," InitVal)*> "}" => {
        let mut iv_vec = Vec::new();
        iv_vec.push(iv);
        iv_vec.append(& mut ivs.into_iter().map(|(_, iv)| iv).collect());
        InitVal::Array(iv_vec)
    }
}

FuncDef : FuncDef = {
    <fty : Type> <id : ident> "(" <ffp : FuncFParams?> ")" <blk : Block> =>  FuncDef {ty : fty, name : id, params : ffp.unwrap_or(vec![]), body : blk.items}
}

FuncFParams : Vec<FuncFParam> = {
    <ffp : FuncFParam> <ffps : ("," FuncFParam)*> => {
        let mut params = Vec::new();
        params.push(ffp);
        params.append(&mut ffps.into_iter().map(|(_, ffp)| ffp).collect());
        params
    }
}

FuncFParam : FuncFParam = {
    <ty : Type> <id : ident> "[" "]" <decls_dimensions : ("[" Exp "]")*> => {
        let mut dimensions = Vec::new();
        dimensions.push(Dimension::Deduce);
        dimensions.append(&mut decls_dimensions.into_iter().map(| (_, expr, _) | Dimension::Declare(expr)).collect());
        
        FuncFParam {ty : ty, name : id, dimensions : Some(dimensions)}
    },
    <ty : Type> <id : ident> => FuncFParam {ty : ty, name : id, dimensions : None }
}

Block : Block = {
    "{}" => { Block{items : None} },
    "{" <block_items : BlockItem*> "}" => {
        match block_items.len() {
            0 => Block{items : None},
            _ => Block{items : Some(block_items)}
        }
    }
}

BlockItem : BlockItem = {
    <dl : Decl> => BlockItem::Declare(dl),
    <st : Stmt> => BlockItem::Statement(st),
}

Stmt: Stmt = {
    ClosedStmt,
    OpenStmt,
};

ClosedStmt: Stmt = {
    <lval: LVal> "=" <e: Exp> ";" => Stmt::Assign(lval, e),
    <e: Exp> ";" => Stmt::Expression(e),
    ";" => Stmt::NULL,
    <blk: Block> => Stmt::Block(blk),
    "while" "(" <c: Cond> ")" <then: ClosedStmt> => Stmt::While(c, Box::new(then)),
    "break" ";" => Stmt::Break,
    "continue" ";" => Stmt::Continue,
    "return" <e: Exp?> ";" => Stmt::Return(e),
    
    "if" "(" <c: Cond> ")" <then: ClosedStmt> "else" <el: ClosedStmt> 
        => Stmt::IfElse(c, Box::new(then), Some(Box::new(el))),
};

OpenStmt: Stmt = {
    "if" "(" <c: Cond> ")" <then: Stmt> 
        => Stmt::IfElse(c, Box::new(then), None),
    
    "if" "(" <c: Cond> ")" <then: ClosedStmt> "else" <el: OpenStmt> 
        => Stmt::IfElse(c, Box::new(then), Some(Box::new(el))),
};

Exp : Rc<Expr> = {
    <addexpr : AddExp> => addexpr
}

Cond : Rc<Cond> = {
    <lorexpr : LOrExp> => lorexpr
}

LVal : LVal = {
    <id : ident> <es : ("[" Exp "]")*> => {
        let subscripts: Vec<_> = es.into_iter().map(|(_, sub, _)| sub).collect();

        match subscripts.len() {
            0 => LVal {ident : id, subscripts : None},
            _ => LVal {ident : id, subscripts : Some(subscripts)}
        }
    }
}

PrimaryExp : PrimaryExpr = {
    "(" <e : Exp> ")" => PrimaryExpr::Expression(e),
    <lv : LVal> => PrimaryExpr::LValue(lv),
    <nb : Number> => PrimaryExpr::Number(nb),
}

Number : Num = {
    <int : integer> => Num::Int(int),
    <float : float> => Num::Float(float)
}

UnaryOp : Operator = {
    "+" => Operator::Pos,
    "-" => Operator::Neg,
    "!" => Operator::Not,
}

BinaryOp_1 : Operator = {
    "+" => Operator::Add,
    "-" => Operator::Sub,
}

BinaryOp_2 : Operator = {
    "*" => Operator::Mul,
    "/" => Operator::Div,
    "%" => Operator::Mod,
}

BinaryOp_3 : Operator = {
    "<" => Operator::Ls,
    ">" => Operator::Gt,
    "<=" => Operator::Le,
    ">=" => Operator::Ge,
}

BinaryOp_4 : Operator = {
    "==" => Operator::Eq,
    "!=" => Operator::Ne
}

BinaryOp_5 : Operator = {
    "&&" => Operator::And
}

BinaryOp_6 : Operator = {
    "||" => Operator::Or
}

UnaryExp : Rc<UnaryExpr> = {
    <pe : PrimaryExp> => {
        match pe {
            PrimaryExpr::Number(num) => Rc::new(UnaryExpr {inner : Some(ParenExpr::Expression(Box::new(pe))), op : None, next : None, constant : Some(num) }),
            _ => Rc::new(UnaryExpr {inner : Some(ParenExpr::Expression(Box::new(pe))), op : None, next : None, constant : None }),
        }
    },
    <id : ident> "(" <frps : FuncRParams> ")" => Rc::new(UnaryExpr {inner : Some(ParenExpr::FunctionCall(Box::new(CallExpr{ident : id, params : Some(frps)}))), op : None, next : None, constant : None}),
    <id : ident> "(" ")" => Rc::new(UnaryExpr {inner : Some(ParenExpr::FunctionCall(Box::new(CallExpr{ident : id, params : None}))), op : None, next : None, constant : None }),
    <uop : UnaryOp> <ue : UnaryExp> => {
        if ue.constant.is_none(){
            Rc::new(UnaryExpr {inner : None, op : Some(uop), next : Some(ue), constant : None })
        } else {
            let inner = ue.constant.unwrap();
            let new_num = match inner {
                Num::Int(i32) => match uop {
                    Operator::Pos => Num::Int(i32),
                    Operator::Neg => Num::Int(i32 * -1),
                    Operator::Not => Num::Int( if i32 == 0 { 1 } else { 0 }),
                    _ => panic!()
                }
                Num::Float(f32) => match uop {
                    Operator::Pos => Num::Float(f32),
                    Operator::Neg => Num::Float(f32 * -1.0),
                    Operator::Not => Num::Float( if f32 == 0.0 { 1.0 } else { 0.0 }),
                    _ => panic!()
                }
            };

            Rc::new(UnaryExpr {inner : None, op : Some(uop), next : Some(ue), constant : Some(new_num) })
        }
    }
}

FuncRParams : Vec<Rc<FuncRParam>> = {
    <e : Exp> <ee : ("," Exp)*> => {
        let mut frps = Vec::new();
        frps.push(e);
        frps.append(&mut ee.into_iter().map(|(_, e)| e).collect());
        frps
    }
}

MulExp : Rc<MulExpr> = {
    <prime : UnaryExp> => Rc::new(MulExpr{lhs : None, rhs : Rc::clone(&prime), op : None, constant : prime.constant.clone() }),
    <peer : MulExp> <op_2 : BinaryOp_2> <prime : UnaryExp> => {
        if peer.constant.is_none() || prime.constant.is_none() {
            Rc::new(MulExpr {lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_2), constant : None })
        } else {
            let inner = peer.constant.unwrap();
            let new_num = match inner {
                Num::Int(i32) => match op_2 {
                    Operator::Mul => Num::Int(i32 * prime.constant.unwrap().as_int().unwrap()),
                    Operator::Div => Num::Int(i32 / prime.constant.unwrap().as_int().unwrap()),
                    Operator::Mod => Num::Int(i32 % prime.constant.unwrap().as_int().unwrap()),
                    _ => panic!()
                }
                Num::Float(f32) => match op_2 {
                    Operator::Mul => Num::Float(f32 * prime.constant.unwrap().as_float().unwrap()),
                    Operator::Div => Num::Float(f32 / prime.constant.unwrap().as_float().unwrap()),
                    Operator::Mod => Num::Float(f32 % prime.constant.unwrap().as_float().unwrap()),
                    _ => panic!()
                }
            };

            Rc::new(MulExpr {lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_2), constant : Some(new_num) })
        }
    }
}

AddExp : Rc<AddExpr> = {
    <prime : MulExp> => Rc::new(AddExpr{lhs : None, rhs : Rc::clone(&prime), op : None, constant : prime.constant.clone()}),
    <peer : AddExp> <op_1 : BinaryOp_1> <prime : MulExp> => {
        if peer.constant.is_none() || prime.constant.is_none() {
            Rc::new(AddExpr {lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_1), constant : None })
        } else {
            let inner = peer.constant.unwrap();
            let new_num = match inner {
                Num::Int(i32) => match op_1 {
                    Operator::Add => Num::Int(i32 + prime.constant.unwrap().as_int().unwrap()),
                    Operator::Sub => Num::Int(i32 - prime.constant.unwrap().as_int().unwrap()),
                    _ => panic!()
                }
                Num::Float(f32) => match op_1 {
                    Operator::Add => Num::Float(f32 + prime.constant.unwrap().as_float().unwrap()),
                    Operator::Sub => Num::Float(f32 - prime.constant.unwrap().as_float().unwrap()),
                    _ => panic!()
                }
            };

            Rc::new(AddExpr {lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_1), constant : Some(new_num) })
        }
    }
}

RelExp : Rc<RelExpr> = {
    <prime : AddExp> => Rc::new(RelExpr{lhs : None, rhs : Rc::clone(&prime), op : None, constant : prime.constant.clone()}),
    <peer : RelExp> <op_3 : BinaryOp_3> <prime : AddExp> => {
        let new_peer = Rc::new(RelExpr{lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_3), constant : None});
        new_peer
    }
}

EqExp : Rc<EqExpr> = {
    <prime : RelExp> => Rc::new(EqExpr{lhs : None, rhs : Rc::clone(&prime), op : None, constant : prime.constant.clone()}),
    <peer : EqExp> <op_4 : BinaryOp_4> <prime : RelExp> => {
        let new_peer = Rc::new(EqExpr{lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_4), constant : None});
        new_peer
    }
}

LAndExp : Rc<LAndExpr> = {
    <prime : EqExp> => Rc::new(LAndExpr{lhs : None, rhs : Rc::clone(&prime), op : None, constant : prime.constant.clone()}),
    <peer : LAndExp> <op_5 : BinaryOp_5> <prime : EqExp> => {
        let new_peer = Rc::new(LAndExpr{lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_5), constant : None});
        new_peer
    }
}

LOrExp : Rc<LOrExpr> = {
    <prime : LAndExp> => Rc::new(LOrExpr{lhs : None, rhs : Rc::clone(&prime), op : None, constant : prime.constant.clone()}),
    <peer : LOrExp> <op_6 : BinaryOp_6> <prime : LAndExp> => {
        let new_peer = Rc::new(LOrExpr{lhs : Some(Rc::clone(&peer)), rhs : prime, op : Some(op_6), constant : None});
        new_peer
    }
}

ConstExp : Rc<AddExpr> = {
    <ae : AddExp> => ae
}

Const : () = "const";
Int : BType = "int" => BType::Int;
Float : BType = "float" => BType::Float;
Void : BType = "void" => BType::Void;
Return : () = "return";
Break : () = "break";
If : () = "if";
Else : () = "else";
Continue : () = "continue";
While : () = "while"; 

ident : String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();

integer: i32 = {
    r"0" => 0,
    r"[1-9][0-9]*" => <>.parse::<i32>().unwrap(),
    r"0[0-7]+" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<> [2..], 16).unwrap(),
};

float: f32 = {
    r"(([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+))([eE][\+-]?[0-9]+)?" => <>.parse::<f32>().unwrap(),
    r"[0-9]+[eE][\+-]?[0-9]+" => <>.parse::<f32>().unwrap(),
    r"0[xX](([0-9a-fA-F]+)|([0-9a-fA-F]+\.[0-9a-fA-F]*)|([0-9a-fA-F]*\.[0-9a-fA-F]+))[pP][\+-]?[0-9]+" => f32::from_str(<>).unwrap(),
};

match {
    r"\s+" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
}else {
    _
}